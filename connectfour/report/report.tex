\documentclass[a4paper, titlepage]{article}

\usepackage{courier} % Required for the courier font
\usepackage{listings}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[bookmarks]{hyperref}

\lstset{
mathescape=true,
basicstyle=\ttfamily,
numbers=left
}

\begin{document}

\title{Exercise Lecture 4}
\author{Sigurt Dinesen \\sidi@itu.dk \\\\ Hans Pagh \\hkkp@itu.dk 
\\\\Jens Egholm \\jegp@itu.dk}
\maketitle
\pagebreak

\section*{Evaluation}
\subsection*{Minimax}
For evaluating the heuristics we use the minimax algorithm with alpha-beta pruning to
search for the moves with maximum and minimum utility recursively. 
For searching we use iterative deepening with an incrementing depth and a timer to cut off
the search. Since the search can potentially be cut off before traversing the entire tree, 
the iterative deepening ensures an evenly distributed heuristic in contrast to a depth-first
approach.
\subsubsection*{Cache}
We have implemented a cache to store already explored boards. This is done to ensure that 
two equal boards does not get calculated twice. Furthermore we also mirrored the 
board states to shrink the search space.

\subsubsection{Stalling and Quick win}
When our AI reaches the bottom of our search it can sure tell if its going to lose or win. 
But this is only against a optimal player. So even though the AI knows it has lost, it 
makes moves that will make the game as long as possible to make room for the suboptimal 
opponents to make mistakes. The same mechanism\footnote{The implementation uses a trick 
in the \texttt{utility} method, which both affects the h-values of winning and losing 
states.} also allows for the heuristic to move
towards winning states, just to spare the opponent of any (further) humiliation.

\section*{Heuristics}
\subsection*{Knowledge base}
\input{knowledge}

\subsection*{Threats}
The Threats heuristic evaluates the state of a board based on the number of threats on 
the board. 
A threat is defined as position where either player can win the game, which simply means a 
position where either plays have 3 connected coins and an open position to put the last coin. 
The threats are then further categorized into even and odd threats, based on the row they 
where found in. By analysing these threats we can force the opponent to play moves in the 
late game, that makes the AI win. An example of this is when there is only one column left, 
the opponent is forced to play in this column, earlier in the game the AI made sure to make a 
threat in this column so it will win in this scenario. By investigating strategies and tactics 
online we found the following rules to evaluate the threats on the board.
\footnote{http://asingleneuron.com/2012/08/04/connect-four/}

In the following player A is the player who plays the first coin
\begin{itemize} 
	\item If player A had an odd threat, player B had no even threats below this in the same column and player B had no odd threats anywhere else, it was a win for A
	\item If player A had a greater number of odd threats than player B had odd threats and player B had no even threats, it was a win for A	
	\item If neither of these were true and player B had any even threats it was win for B
	\item Else is was a draw state.
\end{itemize} 

\subsection*{Moves to win}
The moves-to-win (MTW) heuristic is based on calculating the number of moves required to 
secure a win. Every time a move is made the heuristic calculates all the possible 
combinations to win a game. First it removes any MTW combinations from the opponent
the new coin was a part of (that MTW is now no longer available) and second it finds 
the combination where there is \texttt{a)} space enough for a possible win and 
\texttt{b)} fewest coins required to win in comparison to others.

These MTW values are updated for both players, but a sligthly larger weight is put on the 
MTW value of the opponent to make sure that an immediate win from the \texttt{max} player 
is given the same weight as an immediate win from the \texttt{min} player. Since the values 
are calculated immediately after the \texttt{max} players turn, the next move cannot be 
made before \texttt{min} moves, and so \texttt{max} would lose.

The heuristic uses a datastructure that is passed down recursively via the 
\texttt{minimax} algorithm, so the heuristic can cache the MTW combinations for each player.
This gives a time advantage because the heuristic only has to calculate new MTW 
combinations for one player at the time.

The heuristic is strong in the beginning because it tries to get as long series of coins
as possible, while preventing the opponent to grow large MTW combinations. It is 
relatively weak in the end-game because it fails to detect some of the challenges 
described in the \textit{Threats} heuristic.

\end{document}

